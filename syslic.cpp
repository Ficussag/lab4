#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}#include <iostream>
#include <string>
#include <conio.h>
#include <stack>
#include <fstream>

using namespace std;

class Cafedra
{
public:
	string nameCafedra;
	stack<string> FullNameTeacher;
	int countTeacher;
	int numberAuditor;
	int Corpus;
	Cafedra* next;
};

typedef Cafedra* Cfp;

class SpisokCafedri
{
private:
	Cfp head;
public:
	SpisokCafedri() : head(nullptr) {}

	~SpisokCafedri()
	{
		while (head != nullptr)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
		}
	}

	void addNs()
	{
		Cfp newTail = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newTail->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newTail->countTeacher;
		for (int i = 0; i < newTail->countTeacher; i++) 
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newTail->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newTail->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newTail->Corpus;
		newTail->next = nullptr; // Новый узел будет последним в списке

		// Если список пуст, новый узел становится головным
		if (head == nullptr) {
			head = newTail;
		}
		else {
			// Иначе, обходим список до последнего узла
			Cfp current = head;
			while (current->next != nullptr) {
				current = current->next;
			}
			// Добавляем новый узел в конец списка
			current->next = newTail;
		}
	}


	void add()
	{
		Cfp newHead = new Cafedra;
		cout << "Введите название кафедры: ";
		cin >> newHead->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newHead->countTeacher;
		for (int i = 0; i < newHead->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newHead->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newHead->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newHead->Corpus;
		newHead->next = head;
		head = newHead;
	}

	void addAfter()
	{

		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		if (node == nullptr) 
		{
			cout << "Узел не найден." << endl;
			return;
		}
		cout << "Введите название кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		newCafedra->next = node->next;
		node->next = newCafedra;
	}
	
	Cfp findNode(Cfp head) 
	{
		if (head == nullptr) {
			std::cout << "В списке нет кафедр." << std::endl;
			return nullptr; // Список пуст
		}
		string nameCafedra;
		cout << "Введите название кафедры: ";
		cin >> nameCafedra;

		Cfp current = head;
		while (current != nullptr) {
			if (current->nameCafedra == nameCafedra) {
				return current;
			}
			current = current->next;
		}
		return nullptr; // Узел не найден
	}

	void addBefore()
	{
		Cfp node = findNode(head);
		if (node == nullptr)
		{
			return;
		}
		Cfp newCafedra = new Cafedra;
		cout << "Введите название новой кафедры: ";
		cin >> newCafedra->nameCafedra;
		cout << "Введите кол-во преподователей: ";
		cin >> newCafedra->countTeacher;
		for (int i = 0; i < newCafedra->countTeacher; i++)
		{
			string teather;
			cout << "Введите ФИО каждого преподователя: ";
			cin >> teather;
			newCafedra->FullNameTeacher.push(teather);
		}
		cout << "Введите номер аудитории: ";
		cin >> newCafedra->numberAuditor;
		cout << "Введите номер корпуса: ";
		cin >> newCafedra->Corpus;
		if (node == nullptr || node == head)
		{
			newCafedra->next = head;
			head = newCafedra;
		}
		else
		{
			Cfp prev = head;
			while (prev->next != node) 
			{
				prev = prev->next;
			}
			newCafedra->next = node;
			prev->next = newCafedra;
		}
	}


	void displayCafedrasByCorpus() 
	{
		int corpus;
		cout << "Введите нужный корпус: ";
		cin >> corpus;
		Cfp current = head;
		while (current != nullptr) 
		{
			if (current->Corpus == corpus) 
			{
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}

	void displayCafedrasByAuditorRange()
	{
		int maxAuditor, minAuditor;
		cout << "Введите мин. аудиторию: ";
		cin >> minAuditor;
		cout << "Введите макс. аудиторию: ";
		cin >> maxAuditor;
		Cfp current = head;
		while (current != nullptr)
		{
			if (current->numberAuditor >= minAuditor && current->numberAuditor <= maxAuditor) {
				cout << "Кафедра: " << current->nameCafedra << endl;
				cout << "Количество преподавателей: " << current->countTeacher << endl;
				cout << "Аудитория: " << current->numberAuditor << endl;
				cout << "Корпус: " << current->Corpus << endl;
			}
			current = current->next;
		}
	}



	void display() 
	{
		Cfp current = head;
		if (current == nullptr)
		{
			cout << "Нечего выводить" << endl;
			return;
		}
		while (current != nullptr) 
		{
			cout << "Название кафедры: " << current->nameCafedra << endl;
			cout << "Кол-во преподователей: " << current->countTeacher << endl;
			while (current->FullNameTeacher.size() > 0)
			{
				cout << "ФИО каждого преподователя: " << current->FullNameTeacher.top() << endl;
				current->FullNameTeacher.pop();
			}
			cout << "Номер аудитории: " << current->numberAuditor << endl;
			cout << "Номер корпуса: " << current->Corpus << endl;
			cout << endl;
			current = current->next;
		}
	}

	void maxTeather()
	{
		Cfp current = head;
		if (head == nullptr)
		{
			cout << "Список кафедр пуст" << endl;
			return;
		}
		string maxCafedraName = current->nameCafedra;
		int maxT = current->countTeacher;

		while (current->next != nullptr) 
		{
			current = current->next;
			if (current->countTeacher > maxT)
			{
				maxT = current->countTeacher;
				maxCafedraName = current->nameCafedra;
			}
		}
		cout << "Кафедра с максимальным количеством преподавателей: " << maxCafedraName << endl;
		cout << "На этой кафедре " << maxT << " преподавателей." << endl;
	}

	void remove()
	{
		if (head == nullptr)
		{
			cout << "Нечего удалять";
			return;
		}

		string data;
		cout << "Введите название кафедры, которую хотите удалить: ";
		cin >> data;
		if (head->nameCafedra == data)
		{
			Cfp temp = head;
			head = head->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		
		Cfp current = head;
		while (current->next != nullptr && current->next->nameCafedra != data)
		{
			current = current->next;
		}
		if (current->next != nullptr)
		{
			Cfp temp = current->next;
			current->next = current->next->next;
			delete temp;
			cout << "Кафедра " << data << " успешно удалена!" << endl;
			return;
		}
		cout << "Такой кафедры нету!" << endl;
	}

	void saveToFile() {
		string path;
		cout << "Введите название к файлу: ";
		cin >> path;
		ofstream outFile(path, std::ios::binary);

		Cfp current = head;
		while (current != nullptr) {
			// Запись данных кафедры в файл
			outFile << current->nameCafedra << endl;
			outFile << current->countTeacher << endl;
			outFile << current->numberAuditor << endl;
			outFile << current->Corpus << endl;
			// Запись данных преподавателей
			for (int i = 0; i < current->countTeacher; i++) {
				std::string teacher;
				if (!current->FullNameTeacher.empty()) {
					teacher = current->FullNameTeacher.top();
					current->FullNameTeacher.pop();
				}
				outFile.write(teacher.c_str(), teacher.size() + 1); // +1 для нулевого символа в конце строки
			}

			current = current->next;
		}

		outFile.close();
	}

	void loadFromFile() {
		string path;
		cout << "Введите путь к файлу: ";
		cin >> path;
		ifstream inFile(path, ostream::app);
		if (!inFile) {
			std::cerr << "Ошибка при открытии файла" << std::endl;
			return;
		}

		string line;
		while (getline(inFile, line)) {
			Cfp newCafedra = new Cafedra;
			newCafedra->nameCafedra = line;
			getline(inFile, line);
			newCafedra->countTeacher = stoi(line);
			getline(inFile, line);
			newCafedra->numberAuditor = stoi(line);
			getline(inFile, line);
			newCafedra->Corpus = stoi(line);

			// Чтение данных преподавателей
			while (getline(inFile, line) && !line.empty()) {
				newCafedra->FullNameTeacher.push(line);
			}

			newCafedra->next = head;
			head = newCafedra;
		}

		inFile.close();
	}

};

typedef SpisokCafedri* Spisok;

int main()
{
	setlocale(0, "ru");
	SpisokCafedri Sp;
	
	while (1)
	{
		cout << endl;
		cout << "Напишите одну из букв:			A - Добавить кафедру в нс" << endl;
		cout << "					S - Добавить кафедру в кс" << endl;
		cout << "					D - Добавить кафедру после определенной кф" << endl;
		cout << "					F - Добавить кафедру перед определенной кф" << endl;
		cout << "					Q - Вывод всех кафедр в определенном корпусе" << endl;
		cout << "					W - Вывод всех кафедр в диапазоне введенных аудиторий" << endl;
		cout << "					E - Вывод всех кафедр" << endl;
		cout << "					R - Вывод кафедры с максимальным кол-вом преподователей" << endl;
		cout << "					Z - Удаление кафедры из списка" << endl;
		cout << "					X - Сохранить и выйти" << endl;
		cout << "					O - Открыть файл" << endl;
		cout << "					P - Выйти" << endl;

		switch (_getch())
		{
			case 'a': case 'A':
			{
				Sp.addNs();
				break;
			}
			case 's': case 'S':
			{
				Sp.add();
				break;
			}
			case 'd': case 'D':
			{
				Sp.addAfter();
				break;
			}
			case 'f': case 'F':
			{
				Sp.addBefore();
				break;
			}
			case 'q': case 'Q':
			{
				Sp.displayCafedrasByCorpus();
				break;
			}
			case 'w': case 'W':
			{
				Sp.displayCafedrasByAuditorRange();
				break;
			}
			case 'e': case 'E':
			{
				Sp.display();
				break;
			}
			case 'r': case 'R':
			{
 				Sp.maxTeather();
				break;
			}
			case 'z': case 'Z':
			{
				Sp.remove();
				break;
			}
			case 'x': case 'X':
				Sp.saveToFile();
				return 0;
				break;
			case 'o': case 'O':
				Sp.loadFromFile();
				break;
			case 'p': case 'P':
				return 0;
				break;
			default:
				cout << "Ошибка, блин блинский :(" << endl;
		}

	}
	return 0;
}
